# 飞机大战游戏 (AircraftWar)

## 项目简介

这是一个基于 Java Swing 开发的飞机大战游戏，采用多种设计模式实现了可扩展的游戏架构。游戏支持三种难度级别（简单、普通、困难），并提供音效控制、分数记录等功能。

## 核心设计模式

本项目综合运用了以下设计模式：

- **模板模式 (Template Pattern)**：定义游戏流程框架，不同难度继承抽象类实现差异化行为
- **工厂模式 (Factory Pattern)**：创建敌机和道具对象
- **单例模式 (Singleton Pattern)**：管理英雄机实例和图像资源
- **策略模式 (Strategy Pattern)**：实现不同的射击策略
- **观察者模式 (Observer Pattern)**：实现游戏事件通知机制
- **DAO模式 (Data Access Object)**：管理分数数据的持久化

## 游戏难度设计

### 一、应用场景分析

#### 1. 三种游戏难度设计

游戏采用**模板模式**实现了三种难度级别，通过抽象类 `AbstractGame` 定义统一的游戏流程，具体难度由子类 `EasyGame`、`NormalGame`、`HardGame` 实现。

**简单模式 (Easy)**
- 适合新手玩家熟悉游戏机制
- 敌机数量少、血量低、速度慢
- 无 Boss 敌机，难度不随时间增加
- 射击频率快，玩家操作压力小

**普通模式 (Normal)**
- 适合有一定经验的玩家
- 敌机数量和属性适中
- 600分产生Boss，Boss血量固定500
- 每15秒提升一次难度，逐渐增加挑战性

**困难模式 (Hard)**
- 适合追求高难度挑战的玩家
- 敌机数量多、血量高、速度快
- 500分产生Boss，Boss血量递增（600→750→900...）
- 每10秒提升一次难度，快速进入高强度战斗

#### 2. 影响游戏难度的九大因素

| 难度因素 | 简单模式 | 普通模式 | 困难模式 |
|---------|---------|---------|---------|
| **1. 敌机最大数量** | 3个（固定） | 5个（可提升至7个） | 7个（可提升至10个） |
| **2. 普通敌机血量** | 20（固定） | 30（每15秒+10%） | 40（每10秒+15%） |
| **3. 精英敌机血量** | 60（固定） | 80（每15秒+10%） | 100（每10秒+15%） |
| **4. 普通敌机速度** | 8（固定） | 10（每15秒+8%） | 12（每10秒+10%） |
| **5. 精英敌机速度** | 6（固定） | 8（每15秒+8%） | 10（每10秒+10%） |
| **6. 英雄机射击周期** | 400ms | 300ms | 200ms |
| **7. 敌机产生周期** | 800ms（固定） | 600ms（每15秒-8%，最小400ms） | 400ms（每10秒-10%，最小250ms） |
| **8. 精英敌机概率** | 20%（固定） | 30%（每15秒+3%，最高50%） | 40%（每10秒+4%，最高70%） |
| **9. Boss机制** | 无Boss | 600分/次，固定500血 | 500分/次，血量递增（600+150n） |

#### 3. 难度动态提升机制

**普通模式**：每15秒提升一次
- 敌机血量 +10%
- 敌机速度 +8%
- 敌机产生周期 -8%（最快400ms）
- 精英敌机概率 +3%（最高50%）
- 敌机最大数量 +1（最多7个）

**困难模式**：每10秒提升一次
- 敌机血量 +15%
- 敌机速度 +10%
- 敌机产生周期 -10%（最快250ms）
- 精英敌机概率 +4%（最高70%）
- 敌机最大数量 +1（最多10个）

### 二、模板模式应用场景

#### 实际问题

在飞机大战游戏中，不同难度的游戏流程基本相同（初始化→生成敌机→移动射击→碰撞检测→结束），但具体参数和行为存在差异。如果为每种难度编写完整的游戏逻辑，会导致：

1. **代码重复**：三种难度有大量相同的游戏逻辑
2. **维护困难**：修改游戏流程需要在多处同步修改
3. **扩展性差**：新增难度需要复制大量代码

#### 解决方案

使用**模板模式**将游戏流程抽象化：

- **AbstractGame（抽象模板类）**
  - 定义游戏主循环 `action()` 方法（final，不可重写）
  - 提供抽象方法供子类实现：`initGameParameters()`、`generateEnemy()`、`generateBoss()`、`shouldIncreaseDifficulty()`、`increaseDifficulty()`
  - 实现公共逻辑：移动、射击、碰撞检测、UI绘制等

- **EasyGame / NormalGame / HardGame（具体实现类）**
  - 实现抽象方法，定制各自的参数和行为
  - 继承公共逻辑，无需重复编写

#### 模式优势

1. **代码复用**：公共游戏逻辑在 `AbstractGame` 中实现一次，三种难度共享
2. **统一流程**：`action()` 方法保证游戏流程的一致性和完整性
3. **易于扩展**：新增难度只需继承 `AbstractGame` 并实现几个抽象方法
4. **灵活定制**：每种难度可独立调整参数，互不影响
5. **维护性强**：修改游戏流程只需修改抽象类，所有难度自动更新

### 三、UML类图角色说明

#### 1. AbstractGame（抽象模板类）

**作用**：定义游戏流程框架和公共逻辑

**关键属性**：
- `enemyMaxNumber`：敌机最大数量
- `cycleDuration`：敌机产生周期
- `heroShootPeriod`：英雄机射击周期
- `eliteProbability`：精英敌机产生概率
- `mobEnemyHp / eliteEnemyHp`：敌机血量
- `mobEnemySpeed / eliteEnemySpeed`：敌机速度
- `bossScoreThreshold`：Boss出现分数阈值
- `initialBossHp`：Boss初始血量

**关键方法**：
- `action()`：**模板方法**（final），定义游戏主循环流程
- `initGameParameters()`：**抽象方法**，初始化游戏参数
- `generateEnemy()`：**抽象方法**，生成普通/精英敌机
- `generateBoss()`：**抽象方法**，生成Boss敌机
- `shouldIncreaseDifficulty()`：**抽象方法**，判断是否提升难度
- `increaseDifficulty()`：**抽象方法**，提升难度逻辑
- `getBossHp()`：**抽象方法**，获取Boss血量
- `shootAction()` / `moveAction()` / `crashCheckAction()`：**公共方法**，处理射击、移动、碰撞

#### 2. EasyGame（简单模式实现类）

**作用**：实现简单难度的游戏逻辑

**特点**：
- `initGameParameters()`：设置低难度参数（敌机3个、射击周期400ms、产生周期800ms）
- `shouldIncreaseDifficulty()`：返回 `false`，不提升难度
- `generateBoss()`：空实现，无Boss
- `getBossHp()`：返回0

#### 3. NormalGame（普通模式实现类）

**作用**：实现普通难度的游戏逻辑

**特点**：
- `initGameParameters()`：设置中等难度参数（敌机5个、射击周期300ms、产生周期600ms）
- `shouldIncreaseDifficulty()`：每15秒返回 `true`
- `increaseDifficulty()`：提升血量、速度、概率等（幅度适中）
- `generateBoss()`：600分产生Boss
- `getBossHp()`：固定返回500

#### 4. HardGame（困难模式实现类）

**作用**：实现困难难度的游戏逻辑

**特点**：
- `initGameParameters()`：设置高难度参数（敌机7个、射击周期200ms、产生周期400ms）
- `shouldIncreaseDifficulty()`：每10秒返回 `true`
- `increaseDifficulty()`：提升血量、速度、概率等（幅度较大）
- `generateBoss()`：500分产生Boss
- `getBossHp()`：递增血量（600 + 150 * (次数-1)）

#### 5. Menu（客户端）

**作用**：根据用户选择创建对应难度的游戏实例

**关键代码逻辑**：
```
根据用户选择的难度：
  - 选择 "EASY" → 创建 EasyGame 实例
  - 选择 "NORMAL" → 创建 NormalGame 实例
  - 选择 "HARD" → 创建 HardGame 实例
调用 game.action() 启动游戏
```

## 项目结构

```
AircraftWar-base/
├── src/
│   └── edu/hitsz/
│       ├── aircraft/          # 飞机类（工厂模式）
│       ├── application/       # 游戏主程序（模板模式）
│       ├── bullet/            # 子弹类
│       ├── prop/              # 道具类（工厂模式）
│       ├── shoot/             # 射击策略（策略模式）
│       ├── observer/          # 观察者模式
│       └── dao/               # 数据访问对象（DAO模式）
├── images/                    # 游戏素材图片
├── videos/                    # 游戏音效文件
├── uml/                       # UML类图设计
└── lib/                       # 依赖库
```

## 游戏特性

- ✅ 三种难度级别，适合不同水平玩家
- ✅ 动态难度提升机制，保持游戏挑战性
- ✅ Boss战斗系统，增加游戏趣味性
- ✅ 多种敌机类型（普通、精英、超级精英、Boss）
- ✅ 多种道具系统（加血、火力提升、炸弹）
- ✅ 背景音乐和音效系统
- ✅ 分数记录和排行榜功能
- ✅ 控制台实时输出游戏状态信息

## 运行环境

- **JDK版本**：Java 8 或更高
- **开发工具**：IntelliJ IDEA / Eclipse
- **依赖库**：Apache Commons Lang 3.8.1、JUnit 5

## 运行方式

1. 使用 IDE 打开项目
2. 运行 `src/edu/hitsz/application/Main.java`
3. 在菜单界面选择游戏难度
4. 使用鼠标控制英雄机移动，自动射击
5. 消灭敌机获取分数，吃道具提升能力

## 实验总结

### 1. 实验收获

通过本次飞机大战游戏项目，深入学习并实践了多种经典设计模式的应用。模板模式的使用让我理解到如何在保持代码复用性的同时实现灵活的定制化：抽象类定义游戏流程骨架，子类实现具体细节，这种"框架+填空"的设计思想非常优雅。工厂模式的应用解耦了对象创建逻辑，使得新增敌机或道具类型变得简单。策略模式让射击行为可以动态切换，观察者模式实现了事件驱动的通知机制，DAO模式则规范了数据访问层。整个项目结构清晰，各模块职责分明，充分体现了面向对象设计的"开闭原则"——对扩展开放，对修改封闭。

### 2. 值得反思的问题

在实验过程中遇到了几个值得思考的问题：首先是难度平衡的调优，初始设计的难度提升间隔过长、幅度过小，导致玩家感知不明显，后来通过缩短间隔（普通15秒、困难10秒）和增加提升幅度才达到理想效果；其次是多线程同步问题，游戏主循环、音效播放、UI更新需要协调，处理不当会导致卡顿或资源竞争；最后是设计模式的"适度使用"，不能为了用模式而用模式，要根据实际需求选择合适的设计，过度设计反而增加复杂度。这次实验让我认识到，优秀的软件设计不仅需要掌握理论知识，更需要在实践中反复打磨和权衡。

## 开发者

哈尔滨工业大学（深圳）软件工程实验课程项目

---
*本项目仅用于教学和学习目的*

